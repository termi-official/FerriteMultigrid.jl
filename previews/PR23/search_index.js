var documenterSearchIndex = {"docs":
[{"location":"references/#References","page":"References","title":"References","text":"J. B. Schroder. Generalizing Smoothed Aggregation-Based Algebraic Multigrid. PhD dissertation, University of Illinois at Urbana-Champaign (Urbana, Illinois, 2010).\n\n\n\nR. Tielen, M. Möller, D. Göddeke and C. Vuik, p-multigrid methods and their comparison to h-multigrid methods within Isogeometric Analysis. Computer Methods in Applied Mechanics and Engineering 372, 113347 (2020).\n\n\n\n","category":"section"},{"location":"tutorials/#Tutorials","page":"Tutorials","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/#[Linear-Elasticity](@ref-tutorial-linear-elasticity)","page":"Tutorials","title":"Linear Elasticity","text":"","category":"section"},{"location":"tutorials/linear_elasticity/#tutorial-linear-elasticity","page":"Linear Elasticity","title":"Linear Elasticity","text":"(Image: )\n\nFigure 1: Linear elastically deformed 1mm times 1mm Ferrite logo.\n\nnote: Note\nThe full explanation for the underlying FEM theory in this example can be found in the Linear Elasticity tutorial of the Ferrite.jl documentation.","category":"section"},{"location":"tutorials/linear_elasticity/#Implementation","page":"Linear Elasticity","title":"Implementation","text":"The following code is based on the Linear Elasticity tutorial from the Ferrite.jl documentation, with some comments removed for brevity. There are two main modifications:\n\nFourth-order Lagrange shape functions are used for field approximation: ip = Lagrange{RefTriangle,4}()^2.\nHigh-order quadrature points are used to accommodate the fourth-order shape functions: qr = QuadratureRule{RefTriangle}(8).\n\nusing Ferrite, FerriteGmsh, SparseArrays\nusing Downloads: download\nusing IterativeSolvers, TimerOutputs\n\nEmod = 200.0e3 # Young's modulus [MPa]\nν = 0.3        # Poisson's ratio [-]\n\nGmod = Emod / (2(1 + ν))  # Shear modulus\nKmod = Emod / (3(1 - 2ν)) # Bulk modulus\n\nC = gradient(ϵ -> 2 * Gmod * dev(ϵ) + 3 * Kmod * vol(ϵ), zero(SymmetricTensor{2,2}))\n\nfunction assemble_external_forces!(f_ext, dh, facetset, facetvalues, prescribed_traction)\n    # Create a temporary array for the facet's local contributions to the external force vector\n    fe_ext = zeros(getnbasefunctions(facetvalues))\n    for facet in FacetIterator(dh, facetset)\n        # Update the facetvalues to the correct facet number\n        reinit!(facetvalues, facet)\n        # Reset the temporary array for the next facet\n        fill!(fe_ext, 0.0)\n        # Access the cell's coordinates\n        cell_coordinates = getcoordinates(facet)\n        for qp in 1:getnquadpoints(facetvalues)\n            # Calculate the global coordinate of the quadrature point.\n            x = spatial_coordinate(facetvalues, qp, cell_coordinates)\n            tₚ = prescribed_traction(x)\n            # Get the integration weight for the current quadrature point.\n            dΓ = getdetJdV(facetvalues, qp)\n            for i in 1:getnbasefunctions(facetvalues)\n                Nᵢ = shape_value(facetvalues, qp, i)\n                fe_ext[i] += tₚ ⋅ Nᵢ * dΓ\n            end\n        end\n        # Add the local contributions to the correct indices in the global external force vector\n        assemble!(f_ext, celldofs(facet), fe_ext)\n    end\n    return f_ext\nend\n\nfunction assemble_cell!(ke, cellvalues, C)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # Get the integration weight for the quadrature point\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:getnbasefunctions(cellvalues)\n            # Gradient of the test function\n            ∇Nᵢ = shape_gradient(cellvalues, q_point, i)\n            for j in 1:getnbasefunctions(cellvalues)\n                # Symmetric gradient of the trial function\n                ∇ˢʸᵐNⱼ = shape_symmetric_gradient(cellvalues, q_point, j)\n                ke[i, j] += (∇Nᵢ ⊡ C ⊡ ∇ˢʸᵐNⱼ) * dΩ\n            end\n        end\n    end\n    return ke\nend\n\nfunction assemble_global!(K, dh, cellvalues, C)\n    # Allocate the element stiffness matrix\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ke = zeros(n_basefuncs, n_basefuncs)\n    # Create an assembler\n    assembler = start_assemble(K)\n    # Loop over all cells\n    for cell in CellIterator(dh)\n        # Update the shape function gradients based on the cell coordinates\n        reinit!(cellvalues, cell)\n        # Reset the element stiffness matrix\n        fill!(ke, 0.0)\n        # Compute element contribution\n        assemble_cell!(ke, cellvalues, C)\n        # Assemble ke into K\n        assemble!(assembler, celldofs(cell), ke)\n    end\n    return K\nend\n\nfunction linear_elasticity_2d(C)\n    logo_mesh = \"logo.geo\"\n    asset_url = \"https://raw.githubusercontent.com/Ferrite-FEM/Ferrite.jl/gh-pages/assets/\"\n    isfile(logo_mesh) || download(string(asset_url, logo_mesh), logo_mesh)\n\n    grid = togrid(logo_mesh)\n    addfacetset!(grid, \"top\", x -> x[2] ≈ 1.0) # facets for which x[2] ≈ 1.0 for all nodes\n    addfacetset!(grid, \"left\", x -> abs(x[1]) < 1.0e-6)\n    addfacetset!(grid, \"bottom\", x -> abs(x[2]) < 1.0e-6)\n\n    dim = 2\n    order = 4\n    ip = Lagrange{RefTriangle,order}()^dim # vector valued interpolation\n    ip_coarse = Lagrange{RefTriangle,1}()^dim\n\n    qr = QuadratureRule{RefTriangle}(8)\n    qr_face = FacetQuadratureRule{RefTriangle}(6)\n\n    cellvalues = CellValues(qr, ip)\n    facetvalues = FacetValues(qr_face, ip)\n\n    dh = DofHandler(grid)\n    add!(dh, :u, ip)\n    close!(dh)\n\n    dh_coarse = DofHandler(grid)\n    add!(dh_coarse, :u, ip_coarse)\n    close!(dh_coarse)\n\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"bottom\"), (x, t) -> 0.0, 2))\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"left\"), (x, t) -> 0.0, 1))\n    close!(ch)\n\n    traction(x) = Vec(0.0, 20.0e3 * x[1])\n\n    A = allocate_matrix(dh)\n    assemble_global!(A, dh, cellvalues, C)\n\n    b = zeros(ndofs(dh))\n    assemble_external_forces!(b, dh, getfacetset(grid, \"top\"), facetvalues, traction)\n    apply!(A, b, ch)\n\n    return A, b, dh, dh_coarse, cellvalues, ch\nend","category":"section"},{"location":"tutorials/linear_elasticity/#Near-Null-Space-(NNS)","page":"Linear Elasticity","title":"Near Null Space (NNS)","text":"In multigrid methods for problems with vector-valued unknowns, such as linear elasticity, the near null space represents the low energy mode or the smooth error that needs to be captured in the coarser grid when using SA-AMG (Smoothed Aggregation Algebraic Multigrid), more on the topic can be found  in Schroder [1].\n\nFor 2D linear elasticity problems, the rigid body modes are:\n\nTranslation in the x-direction,\nTranslation in the y-direction,\nRotation about the z-axis (i.e., x_3): each point (x, y) is mapped to (-y, x).\n\nThe function create_nns constructs the NNS matrix B ∈ ℝ^{n × 3}, where n is the number of degrees of freedom (DOFs) for the case of p = 1 (i.e., linear interpolation), because B is only relevant for AMG.\n\nfunction create_nns(dh, fieldname = first(dh.field_names))\n    @assert length(dh.field_names) == 1 \"Only a single field is supported for now.\"\n\n    coords_flat = zeros(ndofs(dh))\n    apply_analytical!(coords_flat, dh, fieldname, x -> x)\n    coords = reshape(coords_flat, (length(coords_flat) ÷ 2, 2))\n\n    grid = dh.grid\n    B = zeros(Float64, ndofs(dh), 3)\n    B[1:2:end, 1] .= 1 # x - translation\n    B[2:2:end, 2] .= 1 # y - translation\n\n    # in-plane rotation (x,y) → (-y,x)\n    x = coords[:, 1]\n    y = coords[:, 2]\n    B[1:2:end, 3] .= -y\n    B[2:2:end, 3] .= x\n\n    return B\nend","category":"section"},{"location":"tutorials/linear_elasticity/#Setup-the-linear-elasticity-problem","page":"Linear Elasticity","title":"Setup the linear elasticity problem","text":"Load FerriteMultigrid to access the p-multigrid solver.\n\nusing FerriteMultigrid\n\nConstruct the linear elasticity problem with 2nd order polynomial shape functions.\n\nA, b, dh, dh_coarse, cellvalues, ch = linear_elasticity_2d(C);\nnothing #hide\n\nConstruct the near null space (NNS) matrix\n\nB = create_nns(dh_coarse)\n\ndanger: Danger\nSince NNS matrix is only relevant for AMG, and it is not used in the p-multigrid solver, therefore, B has to provided using linear field approximation (i.e., p = 1) when using AMG as the coarse solver, otherwise (e.g., using Pinv as the coarse solver), then we don't have to provide it.\n\nConstruct the finite element space mathcalV_hp = 2\n\nfe_space = FESpace(dh, cellvalues, ch)","category":"section"},{"location":"tutorials/linear_elasticity/#P-multigrid-Configuration","page":"Linear Elasticity","title":"P-multigrid Configuration","text":"reset_timer!()","category":"section"},{"location":"tutorials/linear_elasticity/#0.-CG-as-baseline","page":"Linear Elasticity","title":"0. CG as baseline","text":"@timeit \"CG\" x_cg = IterativeSolvers.cg(A, b; maxiter = 1000, verbose=false)","category":"section"},{"location":"tutorials/linear_elasticity/#1.-Galerkin-Coarsening-Strategy","page":"Linear Elasticity","title":"1. Galerkin Coarsening Strategy","text":"config_gal = pmultigrid_config(coarse_strategy = Galerkin())\n@timeit \"Galerkin only\" x_gal, res_gal = solve(A, b,fe_space, config_gal;B = B, log=true, rtol = 1e-10)\n\nbuilder_gal = PMultigridPreconBuilder(fe_space, config_gal)\n@timeit \"Build preconditioner\" Pl_gal = builder_gal(A)[1]\n@timeit \"Galerkin CG\" IterativeSolvers.cg(A, b; Pl = Pl_gal, maxiter = 1000, verbose=false)","category":"section"},{"location":"tutorials/linear_elasticity/#2.-Rediscretization-Coarsening-Strategy","page":"Linear Elasticity","title":"2. Rediscretization Coarsening Strategy","text":"# Rediscretization Coarsening Strategy\nconfig_red = pmultigrid_config(coarse_strategy = Rediscretization(LinearElasticityMultigrid(C)))\n@timeit \"Rediscretization only\" x_red, res_red = solve(A, b, fe_space, config_red; B = B, log=true, rtol = 1e-10)\n\nbuilder_red = PMultigridPreconBuilder(fe_space, config_red)\n@timeit \"Build preconditioner\" Pl_red = builder_red(A)[1]\n@timeit \"Rediscretization CG\" IterativeSolvers.cg(A, b; Pl = Pl_red, maxiter = 1000, verbose=false)\n\nprint_timer(title = \"Analysis with $(getncells(dh.grid)) elements\", linechars = :ascii)","category":"section"},{"location":"tutorials/linear_elasticity/#Test-the-solution","page":"Linear Elasticity","title":"Test the solution","text":"using Test\n@testset \"Linear Elasticity Example\" begin\n    println(\"Final residual with Galerkin coarsening: \", res_gal[end])\n    @test A * x_gal ≈ b atol=1e-4\n    println(\"Final residual with Rediscretization coarsening: \", res_red[end])\n    @test A * x_red ≈ b atol=1e-4\nend","category":"section"},{"location":"tutorials/linear_elasticity/#linear-elasticity-plain-program","page":"Linear Elasticity","title":"Plain program","text":"Here follows a version of the program without any comments. The file is also available here: linear_elasticity.jl.\n\nusing Ferrite, FerriteGmsh, SparseArrays\nusing Downloads: download\nusing IterativeSolvers, TimerOutputs\n\nEmod = 200.0e3 # Young's modulus [MPa]\nν = 0.3        # Poisson's ratio [-]\n\nGmod = Emod / (2(1 + ν))  # Shear modulus\nKmod = Emod / (3(1 - 2ν)) # Bulk modulus\n\nC = gradient(ϵ -> 2 * Gmod * dev(ϵ) + 3 * Kmod * vol(ϵ), zero(SymmetricTensor{2,2}))\n\nfunction assemble_external_forces!(f_ext, dh, facetset, facetvalues, prescribed_traction)\n    # Create a temporary array for the facet's local contributions to the external force vector\n    fe_ext = zeros(getnbasefunctions(facetvalues))\n    for facet in FacetIterator(dh, facetset)\n        # Update the facetvalues to the correct facet number\n        reinit!(facetvalues, facet)\n        # Reset the temporary array for the next facet\n        fill!(fe_ext, 0.0)\n        # Access the cell's coordinates\n        cell_coordinates = getcoordinates(facet)\n        for qp in 1:getnquadpoints(facetvalues)\n            # Calculate the global coordinate of the quadrature point.\n            x = spatial_coordinate(facetvalues, qp, cell_coordinates)\n            tₚ = prescribed_traction(x)\n            # Get the integration weight for the current quadrature point.\n            dΓ = getdetJdV(facetvalues, qp)\n            for i in 1:getnbasefunctions(facetvalues)\n                Nᵢ = shape_value(facetvalues, qp, i)\n                fe_ext[i] += tₚ ⋅ Nᵢ * dΓ\n            end\n        end\n        # Add the local contributions to the correct indices in the global external force vector\n        assemble!(f_ext, celldofs(facet), fe_ext)\n    end\n    return f_ext\nend\n\nfunction assemble_cell!(ke, cellvalues, C)\n    for q_point in 1:getnquadpoints(cellvalues)\n        # Get the integration weight for the quadrature point\n        dΩ = getdetJdV(cellvalues, q_point)\n        for i in 1:getnbasefunctions(cellvalues)\n            # Gradient of the test function\n            ∇Nᵢ = shape_gradient(cellvalues, q_point, i)\n            for j in 1:getnbasefunctions(cellvalues)\n                # Symmetric gradient of the trial function\n                ∇ˢʸᵐNⱼ = shape_symmetric_gradient(cellvalues, q_point, j)\n                ke[i, j] += (∇Nᵢ ⊡ C ⊡ ∇ˢʸᵐNⱼ) * dΩ\n            end\n        end\n    end\n    return ke\nend\n\nfunction assemble_global!(K, dh, cellvalues, C)\n    # Allocate the element stiffness matrix\n    n_basefuncs = getnbasefunctions(cellvalues)\n    ke = zeros(n_basefuncs, n_basefuncs)\n    # Create an assembler\n    assembler = start_assemble(K)\n    # Loop over all cells\n    for cell in CellIterator(dh)\n        # Update the shape function gradients based on the cell coordinates\n        reinit!(cellvalues, cell)\n        # Reset the element stiffness matrix\n        fill!(ke, 0.0)\n        # Compute element contribution\n        assemble_cell!(ke, cellvalues, C)\n        # Assemble ke into K\n        assemble!(assembler, celldofs(cell), ke)\n    end\n    return K\nend\n\nfunction linear_elasticity_2d(C)\n    logo_mesh = \"logo.geo\"\n    asset_url = \"https://raw.githubusercontent.com/Ferrite-FEM/Ferrite.jl/gh-pages/assets/\"\n    isfile(logo_mesh) || download(string(asset_url, logo_mesh), logo_mesh)\n\n    grid = togrid(logo_mesh)\n    addfacetset!(grid, \"top\", x -> x[2] ≈ 1.0) # facets for which x[2] ≈ 1.0 for all nodes\n    addfacetset!(grid, \"left\", x -> abs(x[1]) < 1.0e-6)\n    addfacetset!(grid, \"bottom\", x -> abs(x[2]) < 1.0e-6)\n\n    dim = 2\n    order = 4\n    ip = Lagrange{RefTriangle,order}()^dim # vector valued interpolation\n    ip_coarse = Lagrange{RefTriangle,1}()^dim\n\n    qr = QuadratureRule{RefTriangle}(8)\n    qr_face = FacetQuadratureRule{RefTriangle}(6)\n\n    cellvalues = CellValues(qr, ip)\n    facetvalues = FacetValues(qr_face, ip)\n\n    dh = DofHandler(grid)\n    add!(dh, :u, ip)\n    close!(dh)\n\n    dh_coarse = DofHandler(grid)\n    add!(dh_coarse, :u, ip_coarse)\n    close!(dh_coarse)\n\n    ch = ConstraintHandler(dh)\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"bottom\"), (x, t) -> 0.0, 2))\n    add!(ch, Dirichlet(:u, getfacetset(grid, \"left\"), (x, t) -> 0.0, 1))\n    close!(ch)\n\n    traction(x) = Vec(0.0, 20.0e3 * x[1])\n\n    A = allocate_matrix(dh)\n    assemble_global!(A, dh, cellvalues, C)\n\n    b = zeros(ndofs(dh))\n    assemble_external_forces!(b, dh, getfacetset(grid, \"top\"), facetvalues, traction)\n    apply!(A, b, ch)\n\n    return A, b, dh, dh_coarse, cellvalues, ch\nend\n\nfunction create_nns(dh, fieldname = first(dh.field_names))\n    @assert length(dh.field_names) == 1 \"Only a single field is supported for now.\"\n\n    coords_flat = zeros(ndofs(dh))\n    apply_analytical!(coords_flat, dh, fieldname, x -> x)\n    coords = reshape(coords_flat, (length(coords_flat) ÷ 2, 2))\n\n    grid = dh.grid\n    B = zeros(Float64, ndofs(dh), 3)\n    B[1:2:end, 1] .= 1 # x - translation\n    B[2:2:end, 2] .= 1 # y - translation\n\n    # in-plane rotation (x,y) → (-y,x)\n    x = coords[:, 1]\n    y = coords[:, 2]\n    B[1:2:end, 3] .= -y\n    B[2:2:end, 3] .= x\n\n    return B\nend\n\nusing FerriteMultigrid\n\nA, b, dh, dh_coarse, cellvalues, ch = linear_elasticity_2d(C);\n\nB = create_nns(dh_coarse)\n\nfe_space = FESpace(dh, cellvalues, ch)\n\nreset_timer!()\n\n@timeit \"CG\" x_cg = IterativeSolvers.cg(A, b; maxiter = 1000, verbose=false)\n\nconfig_gal = pmultigrid_config(coarse_strategy = Galerkin())\n@timeit \"Galerkin only\" x_gal, res_gal = solve(A, b,fe_space, config_gal;B = B, log=true, rtol = 1e-10)\n\nbuilder_gal = PMultigridPreconBuilder(fe_space, config_gal)\n@timeit \"Build preconditioner\" Pl_gal = builder_gal(A)[1]\n@timeit \"Galerkin CG\" IterativeSolvers.cg(A, b; Pl = Pl_gal, maxiter = 1000, verbose=false)\n\n# Rediscretization Coarsening Strategy\nconfig_red = pmultigrid_config(coarse_strategy = Rediscretization(LinearElasticityMultigrid(C)))\n@timeit \"Rediscretization only\" x_red, res_red = solve(A, b, fe_space, config_red; B = B, log=true, rtol = 1e-10)\n\nbuilder_red = PMultigridPreconBuilder(fe_space, config_red)\n@timeit \"Build preconditioner\" Pl_red = builder_red(A)[1]\n@timeit \"Rediscretization CG\" IterativeSolvers.cg(A, b; Pl = Pl_red, maxiter = 1000, verbose=false)\n\nprint_timer(title = \"Analysis with $(getncells(dh.grid)) elements\", linechars = :ascii)\n\nusing Test\n@testset \"Linear Elasticity Example\" begin\n    println(\"Final residual with Galerkin coarsening: \", res_gal[end])\n    @test A * x_gal ≈ b atol=1e-4\n    println(\"Final residual with Rediscretization coarsening: \", res_red[end])\n    @test A * x_red ≈ b atol=1e-4\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"api-reference/multigrid_problems/#Multigrid-Problems","page":"Multigrid Problems","title":"Multigrid Problems","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#Interface","page":"Multigrid Problems","title":"Interface","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#Diffusion","page":"Multigrid Problems","title":"Diffusion","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#Linear-Elasticity","page":"Multigrid Problems","title":"Linear Elasticity","text":"","category":"section"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.AbstractPMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.AbstractPMultigrid","text":"abstract type AbstractPMultigrid\n\nThis is an abstract type that can be extended to when Rediscretization strategy is used as coarsening strategy, otherwise it's not required.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.assemble","page":"Multigrid Problems","title":"FerriteMultigrid.assemble","text":"assemble(problem::AbstractPMultigrid, fe_space::FESpace)\n\nThe interface that needs to be implemented to define the Rediscretization strategy for a specific problem type.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.DiffusionMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.DiffusionMultigrid","text":"DiffusionMultigrid{C} <: AbstractPMultigrid\n\nThis struct represents a multigrid problem for diffusion equations with a coefficient C.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/multigrid_problems/#FerriteMultigrid.LinearElasticityMultigrid","page":"Multigrid Problems","title":"FerriteMultigrid.LinearElasticityMultigrid","text":"LinearElasticityMultigrid{TC} <: AbstractPMultigrid\n\nThis struct represents a multigrid problem for linear elasticity equations with a material stiffness tensor `TC\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#Multigrid-Configuration","page":"Multigrid Configuration","title":"Multigrid Configuration","text":"","category":"section"},{"location":"api-reference/pmg_config/#Coarsening-Strategy","page":"Multigrid Configuration","title":"Coarsening Strategy","text":"","category":"section"},{"location":"api-reference/pmg_config/#Projection-Strategy","page":"Multigrid Configuration","title":"Projection Strategy","text":"","category":"section"},{"location":"api-reference/pmg_config/#FerriteMultigrid.PMultigridConfiguration","page":"Multigrid Configuration","title":"FerriteMultigrid.PMultigridConfiguration","text":"PMultigridConfiguration{TC<:AbstractCoarseningStrategy, TP<:AbstractProjectionStrategy}\n\nThis struct represents the configuration for the polynomial multigrid method.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.pmultigrid_config","page":"Multigrid Configuration","title":"FerriteMultigrid.pmultigrid_config","text":"pmultigrid_config(;coarse_strategy = Galerkin(), proj_strategy = DirectProjection())\n\nThis function is the main api to instantiate PMultigridConfiguration.\n\n\n\n\n\n","category":"function"},{"location":"api-reference/pmg_config/#FerriteMultigrid.Galerkin","page":"Multigrid Configuration","title":"FerriteMultigrid.Galerkin","text":"Galerkin <: AbstractCoarseningStrategy\n\nGalerkin coarsening operator can be defined as follows:\n\nA_hp-1 = mathcalI_p^p-1 A_hp mathcalI_p-1^p\n\nand according to Tielen et al. [2] mathcalI_p-1^p is the interpolation operator from the coarse space to the fine space and is defined as follows:\n\nmathcalI_p-1^p (mathbfv_p-1) = (mathbfM_p)^-1 mathbfP_p-1^p  mathbfv_p-1\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.Rediscretization","page":"Multigrid Configuration","title":"FerriteMultigrid.Rediscretization","text":"Rediscretization{TP <: AbstractPMultigrid} <: AbstractCoarseningStrategy\n\nThis struct represents a coarsening strategy that uses the assemble function to obtain the coarse grid operator. It is used when the Rediscretization strategy is specified in the pmultigrid_config. It requires the problem type TP to be a subtype of AbstractPMultigrid.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.DirectProjection","page":"Multigrid Configuration","title":"FerriteMultigrid.DirectProjection","text":"DirectProjection <: AbstractProjectionStrategy\n\nThis struct represents a direct projection from mathcalV_hp to mathcalV_hp=1. \n\n\n\n\n\n","category":"type"},{"location":"api-reference/pmg_config/#FerriteMultigrid.StepProjection","page":"Multigrid Configuration","title":"FerriteMultigrid.StepProjection","text":"StepProjection <: AbstractProjectionStrategy\n\nThis struct represents a projection from mathcalV_hp to mathcalV_hp-step, where step is a positive integer. It is used to reduce the polynomial order by a fixed step size until p = 1.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/fe/#Finite-Element","page":"Finite Element","title":"Finite Element","text":"","category":"section"},{"location":"api-reference/fe/#Finite-Element-Space","page":"Finite Element","title":"Finite Element Space","text":"","category":"section"},{"location":"api-reference/fe/#FerriteMultigrid.FESpace","page":"Finite Element","title":"FerriteMultigrid.FESpace","text":"FESpace{DH<:AbstractDofHandler, CV<:AbstractCellValues, CH<:ConstraintHandler}\n\nA structure that encapsulates the finite element space.\n\nFields\n\ndh::DH: Degree-of-freedom handler \ncv::CV: Cell values\nch::CH: Constraint handler.\n\n\n\n\n\n","category":"type"},{"location":"api-reference/#API-Reference-Overview","page":"API Reference Overview","title":"API Reference Overview","text":"Pages = [\n    \"fe.md\",\n    \"multigrid_problems.md\",\n    \"multilevel.md\",\n    \"pmg_config.md\"\n]","category":"section"},{"location":"api-reference/multilevel/#Multilevel","page":"Multilevel","title":"Multilevel","text":"","category":"section"},{"location":"api-reference/multilevel/#Solve","page":"Multilevel","title":"Solve","text":"","category":"section"},{"location":"api-reference/multilevel/#FerriteMultigrid.solve","page":"Multilevel","title":"FerriteMultigrid.solve","text":"solve(A::AbstractMatrix, b::Vector, fe_space::FESpace, pgrid_config::PMultigridConfiguration = pmultigrid_config(), pcoarse_solvertype::Type{<:CoarseSolver} = SmoothedAggregationCoarseSolver, args...; kwargs...)\n\nThis function solves the linear system Ax = b using polynomial multigrid methods with a coarse solver of type pcoarse_solvertype.\n\nFields\n\nA: The system matrix.\nb: The right-hand side vector.\nfe_space: See FESpace for details on the finite element space.   \npgrid_config: Configuration for the polynomial multigrid method, see PMultigridConfiguration for details.\npcoarse_solvertype: The type of coarse solver to use (e.g., SmoothedAggregationCoarseSolver, Pinv).\nargs...: Additional arguments for the coarse solver.\nkwargs...: Additional keyword arguments for the coarse solver.\n\n\n\n\n\n","category":"function"},{"location":"#FerriteMultigrid","page":"Home","title":"FerriteMultigrid","text":"FerriteMultigrid.jl is a lightweight, flexible p-multigrid framework designed for high-order finite element problems in Julia.   It is built on top of Ferrite.jl and leverages AlgebraicMultigrid.jl as the coarse-grid solver once the approximation is reduced to ( p = 1 ).","category":"section"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"This high level view of the documentation structure will help you find what you are looking for. The document is organized as follows:\n\nTutorials are thoroughly documented examples which guides you through the process of solving finite element problems using p- and A- multigrid methods.\nAPI Reference contains the technical API reference of functions and methods (e.g. the documentation strings).","category":"section"},{"location":"tutorials/hyperelasticity/#tutorial-nonlinear-elasticity","page":"Nonlinear Elasticity","title":"Nonlinear Elasticity","text":"note: Note\nThe full explanation for the underlying FEM theory in this example can be found in the Hyperelasticity tutorial of the Ferrite.jl documentation.","category":"section"},{"location":"tutorials/hyperelasticity/#Implementation","page":"Nonlinear Elasticity","title":"Implementation","text":"The following code is based on the Hyperelasticity tutorial from the Ferrite.jl documentation, with some comments removed for brevity. There are two main modifications:\n\nSecond-order Lagrange shape functions are used for field approximation: ip = Lagrange{RefTriangle,2}()^2.\nFour quadrature points are used to accommodate the second-order shape functions: qr = QuadratureRule{RefTriangle}(4).\n\nusing Ferrite, Tensors, TimerOutputs, IterativeSolvers\n\nusing FerriteMultigrid\n\nstruct NeoHooke\n    μ::Float64\n    λ::Float64\nend\n\nfunction Ψ(C, mp::NeoHooke)\n    μ = mp.μ\n    λ = mp.λ\n    Ic = tr(C)\n    J = sqrt(det(C))\n    return μ / 2 * (Ic - 3 - 2 * log(J)) + λ / 2 * (J - 1)^2\nend\n\nfunction constitutive_driver(C, mp::NeoHooke)\n    # Compute all derivatives in one function call\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, mp), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 2.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend;\n\nfunction assemble_element!(ke, ge, cell, cv, fv, mp, ue, ΓN)\n    # Reinitialize cell values, and reset output arrays\n    reinit!(cv, cell)\n    fill!(ke, 0.0)\n    fill!(ge, 0.0)\n\n    b = Vec{3}((0.0, -0.5, 0.0)) # Body force\n    tn = 0.1 # Traction (to be scaled with surface normal)\n    ndofs = getnbasefunctions(cv)\n\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        # Compute deformation gradient F and right Cauchy-Green tensor C\n        ∇u = function_gradient(cv, qp, ue)\n        F = one(∇u) + ∇u\n        C = tdot(F) # F' ⋅ F\n        # Compute stress and tangent\n        S, ∂S∂C = constitutive_driver(C, mp)\n        P = F ⋅ S\n        I = one(S)\n        ∂P∂F = otimesu(I, S) + 2 * F ⋅ ∂S∂C ⊡ otimesu(F', I)\n\n        # Loop over test functions\n        for i in 1:ndofs\n            # Test function and gradient\n            δui = shape_value(cv, qp, i)\n            ∇δui = shape_gradient(cv, qp, i)\n            # Add contribution to the residual from this test function\n            ge[i] += (∇δui ⊡ P - δui ⋅ b) * dΩ\n\n            ∇δui∂P∂F = ∇δui ⊡ ∂P∂F # Hoisted computation\n            for j in 1:ndofs\n                ∇δuj = shape_gradient(cv, qp, j)\n                # Add contribution to the tangent\n                ke[i, j] += (∇δui∂P∂F ⊡ ∇δuj) * dΩ\n            end\n        end\n    end\n\n    # Surface integral for the traction\n    for facet in 1:nfacets(cell)\n        if (cellid(cell), facet) in ΓN\n            reinit!(fv, cell, facet)\n            for q_point in 1:getnquadpoints(fv)\n                t = tn * getnormal(fv, q_point)\n                dΓ = getdetJdV(fv, q_point)\n                for i in 1:ndofs\n                    δui = shape_value(fv, q_point, i)\n                    ge[i] -= (δui ⋅ t) * dΓ\n                end\n            end\n        end\n    end\n    return\nend;\n\nfunction assemble_global!(K, g, dh, cv, fv, mp, u, ΓN)\n    n = ndofs_per_cell(dh)\n    ke = zeros(n, n)\n    ge = zeros(n)\n\n    # start_assemble resets K and g\n    assembler = start_assemble(K, g)\n\n    # Loop over all cells in the grid\n    for cell in CellIterator(dh)\n        global_dofs = celldofs(cell)\n        ue = u[global_dofs] # element dofs\n        assemble_element!(ke, ge, cell, cv, fv, mp, ue, ΓN)\n        assemble!(assembler, global_dofs, ke, ge)\n    end\n    return\nend;\nnothing #hide","category":"section"},{"location":"tutorials/hyperelasticity/#Near-Null-Space-(NNS)","page":"Nonlinear Elasticity","title":"Near Null Space (NNS)","text":"In multigrid methods for problems with vector-valued unknowns, such as elasticity, the near null space represents the low energy mode or the smooth error that needs to be captured in the coarser grid when using SA-AMG (Smoothed Aggregation Algebraic Multigrid), more on the topic can be found  in Schroder [1].\n\nFor 3D linear elasticity problems, the rigid body modes are:\n\nTranslation in the x-direction,\nTranslation in the y-direction,\nTranslation in the z-direction,\nRotation about the x-axis (i.e., x_1): each point (x, y, z) is mapped to (0, -z, y).\nRotation about the y-axis (i.e., x_2): each point (x, y, z) is mapped to (z, 0, -x).\nRotation about the z-axis (i.e., x_3): each point (x, y, z) is mapped to (-y, x, 0).\n\nThe function create_nns constructs the NNS matrix B ∈ ℝ^{n × 6}, where n is the number of degrees of freedom (DOFs) for the case of p = 1 (i.e., linear interpolation), because B is only relevant for AMG.\n\nfunction create_nns(dh, fieldname = first(dh.field_names))\n    @assert length(dh.field_names) == 1 \"Only a single field is supported for now.\"\n\n    coords_flat = zeros(ndofs(dh))\n    apply_analytical!(coords_flat, dh, fieldname, x -> x)\n    coords = reshape(coords_flat, (length(coords_flat) ÷ 3, 3))\n\n    grid = dh.grid\n    B = zeros(Float64, ndofs(dh), 6)\n    B[1:3:end, 1] .= 1 # x - translation\n    B[2:3:end, 2] .= 1 # y - translation\n    B[3:3:end, 3] .= 1 # z - translation\n\n    # rotations\n    x = coords[:, 1]\n    y = coords[:, 2]\n    z = coords[:, 3]\n    # Around x\n    B[2:3:end, 4] .= -z\n    B[3:3:end, 4] .= y\n    # Around y\n    B[1:3:end, 5] .= z\n    B[3:3:end, 5] .= -x\n    # Around z\n    B[1:3:end, 6] .= -y\n    B[2:3:end, 6] .= x\n\n    return B\nend\n\nfunction _solve()\n    reset_timer!()\n\n    # Generate a grid\n    N = 10\n    L = 1.0\n    left = zero(Vec{3})\n    right = L * ones(Vec{3})\n    grid = generate_grid(Tetrahedron, (N, N, N), left, right)\n\n    # Material parameters\n    E = 10.0\n    ν = 0.3\n    μ = E / (2(1 + ν))\n    λ = (E * ν) / ((1 + ν) * (1 - 2ν))\n    mp = NeoHooke(μ, λ)\n\n    # Finite element base\n    ip = Lagrange{RefTetrahedron, 2}()^3\n    qr = QuadratureRule{RefTetrahedron}(4)\n    qr_facet = FacetQuadratureRule{RefTetrahedron}(3)\n    cv = CellValues(qr, ip)\n    fv = FacetValues(qr_facet, ip)\n\n    # DofHandler\n    dh = DofHandler(grid)\n    add!(dh, :u, ip) # Add a displacement field\n    close!(dh)\n\n    function rotation(X, t)\n        θ = pi / 3 # 60°\n        x, y, z = X\n        return t * Vec{3}(\n            (\n                0.0,\n                L / 2 - y + (y - L / 2) * cos(θ) - (z - L / 2) * sin(θ),\n                L / 2 - z + (y - L / 2) * sin(θ) + (z - L / 2) * cos(θ),\n            )\n        )\n    end\n\n    ch = ConstraintHandler(dh)\n    # Add a homogeneous boundary condition on the \"clamped\" edge\n    dbc = Dirichlet(:u, getfacetset(grid, \"right\"), (x, t) -> [0.0, 0.0, 0.0], [1, 2, 3])\n    add!(ch, dbc)\n    dbc = Dirichlet(:u, getfacetset(grid, \"left\"), (x, t) -> rotation(x, t), [1, 2, 3])\n    add!(ch, dbc)\n    close!(ch)\n    t = 0.5\n    Ferrite.update!(ch, t)\n\n    # Neumann part of the boundary\n    ΓN = union(\n        getfacetset(grid, \"top\"),\n        getfacetset(grid, \"bottom\"),\n        getfacetset(grid, \"front\"),\n        getfacetset(grid, \"back\"),\n    )\n\n    # Pre-allocation of vectors for the solution and Newton increments\n    _ndofs = ndofs(dh)\n    un = zeros(_ndofs) # previous solution vector\n    u = zeros(_ndofs)\n    Δu = zeros(_ndofs)\n    ΔΔu = zeros(_ndofs)\n    apply!(un, ch)\n\n    # Create sparse matrix and residual vector\n    K = allocate_matrix(dh)\n    g = zeros(_ndofs)\n\n    # FIXME this needs better integration\n    dh_coarse = DofHandler(grid)\n    add!(dh_coarse, :u, Lagrange{RefTetrahedron, 1}()^3) # Add a displacement field\n    close!(dh_coarse)\n    B = create_nns(dh_coarse)\n    config_gal = pmultigrid_config(coarse_strategy = Galerkin())\n    fe_space = FESpace(dh, cv, ch)\n\n    builder = PMultigridPreconBuilder(fe_space, config_gal)\n\n    # Perform Newton iterations\n    newton_itr = -1\n    NEWTON_TOL = 1.0e-8\n    NEWTON_MAXITER = 30\n\n    @info ndofs(dh)\n\n    while true\n        newton_itr += 1\n        # Construct the current guess\n        u .= un .+ Δu\n        # Compute residual and tangent for current guess\n        assemble_global!(K, g, dh, cv, fv, mp, u, ΓN)\n        # Apply boundary conditions\n        apply_zero!(K, g, ch)\n        # Compute the residual norm and compare with tolerance\n        normg = norm(g)\n        if normg < NEWTON_TOL\n            break\n        elseif newton_itr > NEWTON_MAXITER\n            error(\"Reached maximum Newton iterations, aborting\")\n        end\n\n        # Compute increment using conjugate gradients\n        fill!(ΔΔu, 0.0)\n        @timeit \"Setup preconditioner\" Pl = builder(K)[1]\n        @timeit \"Galerkin CG\" _, ch_gal = IterativeSolvers.cg!(ΔΔu, K, g; Pl, maxiter = 1000, log=true, verbose=false)\n        @info \"Galerkin CG iterations: $(ch_gal.iters)\"\n        @timeit \"Galerkin only\" solve(K, g, fe_space, config_gal;B = B, log=true, rtol = 1e-10)\n        fill!(ΔΔu, 0.0)\n        @timeit \"CG\" _, ch_cg = IterativeSolvers.cg!(ΔΔu, K, g; maxiter = 1000, log=true, verbose=false)\n        @info \"CG iterations: $(ch_cg.iters)\"\n\n        apply_zero!(ΔΔu, ch)\n        Δu .-= ΔΔu\n    end\n\n    # Save the solution\n    @timeit \"export\" begin\n        VTKGridFile(\"hyperelasticity\", dh) do vtk\n            write_solution(vtk, dh, u)\n        end\n    end\n\n    print_timer(title = \"Analysis with $(getncells(grid)) elements\", linechars = :ascii)\n    return u\nend\n\nu = _solve();\nnothing #hide\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
